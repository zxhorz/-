package com.hengtiansoft.bluemorpho.workbench.enums;

public enum CypherMethod {
	SO_SUMMARY(
			"match(p:Program) where p.isCics = 'N' return 'Program' as name, count(DISTINCT p) as num union " +
			"match(p:Program) where p.isCics = 'Y' return 'CICS' as name, count(DISTINCT p) as num union " +
			"match(p:Paragraph) return 'Paragraph' as name, count(DISTINCT p) as num union " +
			"match(t:Table) return 'Table' as name, count(DISTINCT t) as num union " +
			"match(f:File)  return 'File' as name, count(DISTINCT f) as num union " +
		    "match(c:Copybook) return  'Copybook' as name, count(DISTINCT c) as num union " +			
		    "match(j:JclFile) return 'JCL' as name, count(DISTINCT j) as num union "+
//		    "match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName  return 'SqlLogic' as name, count(DISTINCT r) as num union "+
		    "match(p:Program) return 'cobolLOC' as name, sum(toInt(p.totalLine)) as num union "+
		    "match(c:Copybook) return 'cpyLOC' as name, sum(toInt(c.totalLine)) as num union "+
			"match(j:JclFile) return 'jclLOC' as name, sum(toInt(j.totalLine)) as num "),

    PROGRAM_DETAIL_WITH_QUERY("match(p:Program) where p.nodeId contains {query} optional match (p)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, case p.isCics when 'Y' then 'CICS' when 'N' then 'NON_CICS' end  as type, p.totalLine as lines, COLLECT(DISTINCT(t.name)) as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone"),			
//	PROGRAM_DETAIL_WITH_QUERY("match(p:Program) where p.isCics = 'Y' and p.nodeId contains {query} return p.nodeId as nodeId, p.name as name, 'CICS' as type, p.totalLine as lines, '' as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone union "+
//					"match(p:Program)-[:has_tag]->(t:Tag) where p.isCics = 'Y' and p.nodeId contains {query} return p.nodeId as nodeId, p.name as name, 'CICS' as type, p.totalLine as lines, COLLECT(DISTINCT(t.name)) as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone union "+
//					"match(p:Program) where p.isCics = 'N' and p.nodeId contains {query} return p.nodeId as nodeId, p.name as name, 'NON_CICS' as type, p.totalLine as lines,'' as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone union "+
//					"match(p:Program)-[:has_tag]->(t:Tag) where p.isCics = 'N' and p.nodeId contains {query} return p.nodeId as nodeId, p.name as name, 'NON_CICS' as type, p.totalLine as lines, COLLECT(DISTINCT(t.name)) as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone"
//			),
	PROGRAM_DETAIL("match (p:Program) optional match (p)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, case p.isCics when 'Y' then 'CICS' when 'N' then 'NON_CICS' end  as type, p.totalLine as lines, COLLECT(DISTINCT(t.name)) as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone"),
//	PROGRAM_DETAIL("match(p:Program) where p.isCics = 'Y' return p.nodeId as nodeId, p.name as name, 'CICS' as type, p.totalLine as lines, '' as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone union "+
//					"match(p:Program)-[:has_tag]->(t:Tag) where p.isCics = 'Y' return p.nodeId as nodeId, p.name as name, 'CICS' as type, p.totalLine as lines, COLLECT(DISTINCT(t.name)) as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone union "+
//					"match(p:Program) where p.isCics = 'N' return p.nodeId as nodeId, p.name as name, 'NON_CICS' as type, p.totalLine as lines,'' as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone union "+
//					"match(p:Program)-[:has_tag]->(t:Tag) where p.isCics = 'N' return p.nodeId as nodeId, p.name as name, 'NON_CICS' as type, p.totalLine as lines, COLLECT(DISTINCT(t.name)) as tags, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage, '0') as clone"
//			),
	PARAGRAPH_DETAIL("match (p:Paragraph) where p.isExit ='N' optional match (p)-[:has_tag]->(t:Tag) optional match (n:Program)-[:has_paragraph]-> (p) return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, COLLECT(t.name) as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone"),
//	PARAGRAPH_DETAIL("match (n:Program)-[:has_paragraph]->(p:Paragraph)  where p.isExit ='N' optional match (p)-[:has_tag]->(t:Tag) return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, COLLECT(t.name) as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone"),
//	PARAGRAPH_DETAIL("match(n:Program)-[:has_paragraph]->(p:Paragraph) where p.isExit ='N' return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, '' as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone union "+
//					"match(n:Program)-[:has_paragraph]->(p:Paragraph)-[:has_tag]->(t:Tag) where p.isExit ='N' return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, COLLECT(t.name) as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone"),
	PARAGRAPH_DETAIL_WITH_QUERY("match (p:Paragraph) where p.isExit ='N' and p.nodeId contains {query}  optional match (p)-[:has_tag]->(t:Tag) optional match (n:Program)-[:has_paragraph]-> (p) return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, COLLECT(t.name) as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone"),
//	PARAGRAPH_DETAIL_WITH_QUERY("match (n:Program)-[:has_paragraph]->(p:Paragraph) where p.isExit ='N' and p.nodeId contains {query} optional match (p)-[:has_tag]->(t:Tag) return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, COLLECT(t.name) as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone"),
//	PARAGRAPH_DETAIL_WITH_QUERY("match(n:Program)-[:has_paragraph]->(p:Paragraph) where p.isExit ='N' and p.nodeId contains {query} return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, '' as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone union "+
//					"match(n:Program)-[:has_paragraph]->(p:Paragraph)-[:has_tag]->(t:Tag) where p.isExit ='N' and p.nodeId contains {query} return n.nodeId as programId, n.name as programName, p.nodeId as paragraphId, p.name as paragraphName, p.totalLine as lines, COLLECT(t.name) as tags, p.startLine as startLine, p.endLine as endLine, coalesce(p.complexity,0) as complexity, coalesce(p.clonePercentage,'0') as clone"),
	COPYBOOK_DETAIL("match(c:Copybook) optional match (c)-[:has_tag]->(t:Tag) return c.nodeId as nodeId, c.name as cpyName , COLLECT(t.name) as tags, c.type as type"),
//	COPYBOOK_DETAIL("match(c:Copybook) return c.nodeId as nodeId, c.name as cpyName , '' as tags, c.type as type union "+
//					"match(c1:Copybook)-[:has_tag]->(t:Tag) return c1.nodeId as nodeId, c1.name as cpyName, COLLECT(t.name) as tags, c1.type as type"),
	COPYBOOK_DETAIL_WITH_QUERY("match(c:Copybook) where c.name contains {query} optional match (c)-[:has_tag]->(t:Tag) return c.nodeId as nodeId, c.name as cpyName , COLLECT(t.name) as tags, c.type as type"),
//	COPYBOOK_DETAIL_WITH_QUERY("match(c:Copybook) where c.name contains {query} return c.nodeId as nodeId, c.name as cpyName , '' as tags, c.type as type union "+
//					"match(c1:Copybook)-[:has_tag]->(t:Tag) where c1.name contains {query} return c1.nodeId as nodeId, c1.name as cpyName, COLLECT(t.name) as tags, c1.type as type"),
	JCL_DETAIL("match(j:JclFile) optional match (j)-[:has_tag]->(t:Tag) return j.nodeId as nodeId, j.name as name, case j.isProc when 'Y' then 'PROC' when 'N' then 'JOB' end as type, COLLECT(DISTINCT(t.name)) as tags"),
//	JCL_DETAIL("match(c:JclFile) where c.isProc = 'Y' return c.nodeId as nodeId, c.name as name, 'PROC' as type, '' as tags union "+
//					"match(j:JclFile)-[:has_tag]->(t6:Tag) where j.isProc = 'Y' return j.nodeId as nodeId, j.name as name, 'PROC' as type, COLLECT(DISTINCT(t6.name)) as tags union "+
//					"match(p:JclFile) where p.isProc = 'N' return p.nodeId as nodeId, p.name as name, 'JOB' as type, '' as tags  union "+
//					"match(c:JclFile)-[:has_tag]->(t8:Tag) where c.isProc = 'N' return c.nodeId as nodeId, c.name as name, 'JOB' as type, COLLECT(DISTINCT(t8.name)) as tags"),
	JCL_DETAIL_WITH_QUERY("match(j:JclFile) where j.name contains {query} optional match (j)-[:has_tag]->(t:Tag) return j.nodeId as nodeId, j.name as name, case j.isProc when 'Y' then 'PROC' when 'N' then 'JOB' end as type, COLLECT(DISTINCT(t.name)) as tags"),
//	JCL_DETAIL_WITH_QUERY("match(c:JclFile) where c.isProc = 'Y' and c.name contains {query} return c.nodeId as nodeId, c.name as name, 'PROC' as type, '' as tags union "+
//					"match(j:JclFile)-[:has_tag]->(t6:Tag) where j.isProc = 'Y' and j.name contains {query} return j.nodeId as nodeId, j.name as name, 'PROC' as type, COLLECT(DISTINCT(t6.name)) as tags union "+
//					"match(p:JclFile) where p.isProc = 'N' and p.name contains {query} return p.nodeId as nodeId, p.name as name, 'JOB' as type, '' as tags  union "+
//					"match(c:JclFile)-[:has_tag]->(t8:Tag) where c.isProc = 'N' and c.name contains {query} return c.nodeId as nodeId, c.name as name, 'JOB' as type, COLLECT(DISTINCT(t8.name)) as tags"),	
	JCL_STEP("match(j:JclFile)-[:jclHasExec]->(je:JclExec) where j.nodeId = {nodeId} return je.nodeId as nodeId, je.stepName as stepName, coalesce(je.pgmName,'') as pgmName, coalesce(je.procName,'') as procName"),
	JCL_STEP_PROC_DETAIL("match(j:JclFile) where j.name = {name} and j.isProc = 'Y' return j.nodeId as nodeId limit 1"),
	JCL_STEP_PGM_DETAIL("match(p:Program) where p.name = {name} return p.nodeId as nodeId limit 1"),
	USE_COPYBOOK_DETAIL("match(n:Program)-[:use_copy_command]->(cc:CopyCommand)-[:copy]->(c:Copybook{nodeId:{nodeId}}) return DISTINCT n.nodeId as nodeId, n.name as name, cc.line as line"),
	SQL_USE_TABLE_DETAIL("match(b:BlockPosition)-[r:sqlUseTable]->(t:Table{nodeId:{name}}) return distinct b.nodeId as blockId, coalesce(b.paraName,'') as paraName, coalesce(r.operation,'') as operation"),
	PROGRAM_USE_TABLE_DETAIL("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition) where b.nodeId contains('#methodBody#') and b.paraName  in {names} return distinct  n.nodeId as nodeId"),
	PARAGRAPH_USE_TABLE_DETAIL("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where t.nodeId = {name} and b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName return distinct b1.nodeId as blockId, n.nodeId as programId, p.nodeId as paragraphId, t.nodeId as tableId, r.operation as operation, p.name as paragraphName order by programId, paragraphId, blockId, tableId, operation"),
	DELCARE_CURSOR_IN_PROGRAM("match p=(b:BlockPosition)-[r:sqlUseTable]->(t:Table) where t.nodeId = {name} and b.paraName='' return distinct b.nodeId as blockId, b.location as location, t.nodeId as tableId, r.operation as operation"),
//	ALL_PARAGRAPH_USE_TABLE_DETAIL("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName return distinct n.nodeId as programId, p.nodeId as paragraphId, p.name as paragraphName, p.startLine as paraStartLine, p.endLine as paraEndLine, b1.startLine as startLine, b1.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, b1.copybook as copybook, b1.nodeId as blockId order by programId, paragraphId, blockId, tableId, operation union " + 
//	        "match(p1:Paragraph),(n:BlockPosition)-[r:sqlUseTable]->(t:Table) where p1.nodeId = n.paraName and n.nodeId contains('#SQL_STATEMENT#') return distinct n.nodeId as programId, n.paraName as paragraphId, p1.name as paragraphName, n.startLine as paraStartLine, n.endLine as paraEndLine, n.startLine as startLine, n.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, '' as copybook, '' as blockId order by programId, paragraphId, blockId, tableId, operation"),
//	ALL_PARAGRAPH_USE_TABLE_DETAIL("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName return distinct n.nodeId as programId, p.nodeId as paragraphId, p.name as paragraphName, p.startLine as paraStartLine, p.endLine as paraEndLine, b1.startLine as startLine, b1.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, b1.copybook as copybook, b1.nodeId as blockId order by programId, paragraphId, blockId, tableId, operation union " + 
//	        "match(n:BlockPosition)-[r:sqlUseTable]->(t:Table) where n.nodeId contains('#SQL_STATEMENT#') return distinct n.nodeId as programId, n.paraName as paragraphId, '' as paragraphName, n.startLine as paraStartLine, n.endLine as paraEndLine, n.startLine as startLine, n.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, '' as copybook, '' as blockId order by programId, paragraphId, blockId, tableId, operation"),
	ALL_PARAGRAPH_USE_TABLE_DETAIL1("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName return distinct n.nodeId as programId, p.nodeId as paragraphId, p.name as paragraphName, p.startLine as paraStartLine, p.endLine as paraEndLine, b1.startLine as startLine, b1.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, b1.copybook as copybook, b1.nodeId as blockId order by programId, paragraphId, blockId, tableId, operation"),  
	ALL_PARAGRAPH_USE_TABLE_DETAIL2("match(n:BlockPosition)-[r:sqlUseTable]->(t:Table) where not n.nodeId in {blockIds} and n.nodeId contains('#SQL_STATEMENT#') return distinct n.nodeId as programId, n.paraName as paragraphId, '' as paragraphName, n.startLine as paraStartLine, n.endLine as paraEndLine, n.startLine as startLine, n.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, '' as copybook, '' as blockId order by programId, paragraphId, blockId, tableId, operation"),
//	ALL_PARAGRAPH_USE_TABLE_DETAIL_WITH_QUERY("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName and (n.name contains {query} or t.name contains {query} or p.name contains {query} or r.operation contains {querycommand}) return distinct n.nodeId as programId, p.nodeId as paragraphId, p.name as paragraphName, p.startLine as paraStartLine, p.endLine as paraEndLine, b1.startLine as startLine, b1.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, b1.copybook as copybook, b1.nodeId as blockId order by programId, paragraphId, blockId, tableId, operation union " + 
//	        "match(p1:Paragraph),(n:BlockPosition)-[r:sqlUseTable]->(t:Table) where p1.nodeId = n.paraName and (t.name contains {query} or n.nodeId contains {query} or r.operation contains {querycommand}) and n.nodeId contains('#SQL_STATEMENT#') return distinct n.nodeId as programId, n.paraName as paragraphId, p1.name as paragraphName, n.startLine as paraStartLine, n.endLine as paraEndLine, n.startLine as startLine, n.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, '' as copybook, '' as blockId order by programId, paragraphId, blockId, tableId, operation"),
//    ALL_PARAGRAPH_USE_TABLE_DETAIL_WITH_QUERY("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName and (n.name contains {query} or t.name contains {query} or p.name contains {query} or r.operation contains {querycommand}) return distinct n.nodeId as programId, p.nodeId as paragraphId, p.name as paragraphName, p.startLine as paraStartLine, p.endLine as paraEndLine, b1.startLine as startLine, b1.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, b1.copybook as copybook, b1.nodeId as blockId order by programId, paragraphId, blockId, tableId, operation union " + 
//            "match(n:BlockPosition)-[r:sqlUseTable]->(t:Table) where (t.name contains {query} or n.nodeId contains {query} or r.operation contains {querycommand}) and n.nodeId contains('#SQL_STATEMENT#') return distinct n.nodeId as programId, n.paraName as paragraphId, '' as paragraphName, n.startLine as paraStartLine, n.endLine as paraEndLine, n.startLine as startLine, n.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, '' as copybook, '' as blockId order by programId, paragraphId, blockId, tableId, operation"),
	ALL_PARAGRAPH_USE_TABLE_DETAIL_WITH_QUERY1("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName and (n.nodeId contains {query} or t.name contains {query} or p.nodeId contains {query} or r.operation in {querycommand}) return distinct n.nodeId as programId, p.nodeId as paragraphId, p.name as paragraphName, p.startLine as paraStartLine, p.endLine as paraEndLine, b1.startLine as startLine, b1.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, b1.copybook as copybook, b1.nodeId as blockId order by programId, paragraphId, blockId, tableId, operation"), 
	ALL_PARAGRAPH_USE_TABLE_DETAIL_WITH_QUERY2("match(n:BlockPosition)-[r:sqlUseTable]->(t:Table) where not n.nodeId in {blockIds} and (t.name contains {query} or n.nodeId contains {query} or r.operation in {querycommand}) and n.nodeId contains('#SQL_STATEMENT#') return distinct n.nodeId as programId, n.paraName as paragraphId, '' as paragraphName, n.startLine as paraStartLine, n.endLine as paraEndLine, n.startLine as startLine, n.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation, '' as copybook, '' as blockId order by programId, paragraphId, blockId, tableId, operation"),
	FIND_USE_TABLE("match(n:Program)-[:has_paragraph]->(p:Paragraph)<-[:blockToParagraph]-(b:BlockPosition),(b1:BlockPosition)-[r:sqlUseTable]->(t:Table) where b.nodeId contains('#methodBody#') and  p.isExit = 'N' and b1.paraName = b.paraName and (b1.nodeId+n.nodeId+p.nodeId+t.nodeId+r.operation)<={name} return distinct b1.nodeId as blockId, n.nodeId as programId, p.nodeId as paragraphId, p.name as paragraphName, p.startLine as paraStartLine, p.endLine as paraEndLine, b1.startLine as startLine, b1.endLine as endLine, t.nodeId as tableId, t.name as tableName, r.operation as operation order by programId, paragraphId, blockId, tableId, operation"),
	TABLE_ITEM("match(t:Table) optional match (t)-[:has_tag]->(t1:Tag) return t.nodeId as nodeId, t.name as name, COLLECT(t1.name) as tags"),
//	TABLE_ITEM("match(t:Table)-[:has_tag]->(t1:Tag) return t.nodeId as nodeId, t.name as name, COLLECT(t1.name) as tags union "+
//			   "match(t:Table) return t.nodeId as nodeId, t.name as name, '' as tags"),
	TABLE_ITEM_WITH_QUERY("match(t:Table) where t.name contains {query} optional match (t)-[:has_tag]->(t1:Tag) return t.nodeId as nodeId, t.name as name, COLLECT(t1.name) as tags"),
//	TABLE_ITEM_WITH_QUERY("match(t:Table)-[:has_tag]->(t1:Tag) where t.name contains {query} return t.nodeId as nodeId, t.name as name, COLLECT(t1.name) as tags union "+
//				"match(t:Table) where t.name contains {query} return t.nodeId as nodeId, t.name as name, '' as tags"),
	FILE_ITEM("match(f:File) optional match (f)-[:has_tag]->(t:Tag) return f.nodeId as nodeId, f.name as name, COLLECT(t.name) as tags, coalesce(f.openType,'') as openType , coalesce(f.definitionStart,'1') as definitionStart, coalesce(f.definitionEnd,'1') as definitionEnd"),
//	FILE_ITEM("match(f1:File)-[:has_tag]->(t3:Tag) return f1.nodeId as nodeId, f1.name as name, COLLECT(t3.name) as tags, coalesce(f1.openType,'') as openType , coalesce(f1.definitionStart,'1') as definitionStart, coalesce(f1.definitionEnd,'1') as definitionEnd union "
//			+ "match(f2:File) return f2.nodeId as nodeId, f2.name as name, '' as tags, coalesce(f2.openType,'') as openType, coalesce(f2.definitionStart,'1') as definitionStart, coalesce(f2.definitionEnd,'1') as definitionEnd"),
	FILE_ITEM_WITH_QUERY("match(f:File) where f.name contains {query} optional match (f)-[:has_tag]->(t:Tag) return f.nodeId as nodeId, f.name as name, COLLECT(t.name) as tags, coalesce(f.openType,'') as openType , coalesce(f.definitionStart,'1') as definitionStart, coalesce(f.definitionEnd,'1') as definitionEnd"),
//	FILE_ITEM_WITH_QUERY("match(f1:File)-[:has_tag]->(t3:Tag) where f1.name contains {query}  return f1.nodeId as nodeId, f1.name as name, COLLECT(t3.name) as tags, coalesce(f1.openType,'') as openType , coalesce(f1.definitionStart,'1') as definitionStart, coalesce(f1.definitionEnd,'1') as definitionEnd union "
//			+ "match(f2:File) where f2.name contains {query} return f2.nodeId as nodeId, f2.name as name, '' as tags, coalesce(f2.openType,'') as openType, coalesce(f2.definitionStart,'1') as definitionStart, coalesce(f2.definitionEnd,'1') as definitionEnd"),
    TABLE_DETAIL("MATCH (t:Table{nodeId:{nodeId}})-[:table_has_column]-> (c:Column) RETURN distinct t.nodeId as nodeId, c.name as name, c.type as type ORDER BY c.name"),
    FILE_SUPERID("match(f:File{nodeId:{nodeId}})-[:file_has_record]->(v:Variable) return v.nodeId as superId"),
    FILE_DETAIL("match(v:Variable)-[:is_child_of*0..10]->(vv:Variable{nodeId:{superId}}),(v)-[:variableHasAttrs]->(attr:VariableAttrs)-[:defined_in_copybook]->(c:Copybook) return v.nodeId as nodeId, attr.name as name, attr.type as type, c.nodeId as cpyId, c.name as cpyName "
            + "union match(v:Variable)-[:is_child_of*0..10]->(vv:Variable{nodeId:{superId}}),(v)-[:variableHasAttrs]->(attr:VariableAttrs),(v:Variable)-[:defined_in_program]->(n:Program) return v.nodeId as nodeId, attr.name as name, attr.type as type, '' as cpyId, '' as cpyName"),    
	SQL_DETAIL("match(v:Variable)-[:variableHasAttrs]->(attr:VariableAttrs) where return v.nodeId as nodeId, attr.name as name, attr.type as type"),
    PROGRAM_TAG("match(p:Program) where p.name in {names} optional match (p)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, case t.name when null then '' else t.name end as tagName"),
//	PROGRAM_TAG("match(p:Program)-[:has_tag]->(t:Tag) where p.name in {names} return p.nodeId as nodeId, p.name as name, t.name as tagName union "
//			+"match(p:Program) where p.name in {names} return p.nodeId as nodeId, p.name as name, '' as tagName"),
	PARAGRAPH_TAG("match(p:Paragraph) where p.name in {names} optional match (p)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, case t.name when null then '' else t.name end as tagName"),
//	PARAGRAPH_TAG("match(p:Paragraph)-[:has_tag]->(t:Tag) where p.name in {names} return p.nodeId as nodeId, p.name as name, t.name as tagName union "
//			+"match(p:Paragraph) where p.name in {names} return p.nodeId as nodeId, p.name as name, '' as tagName"),
	TAG_PROGRAM("match(p:Program)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, t.name as tagName"),
	TAG_PROGRAM_WITH_NODEID("match(p:Program)-[:has_tag]->(t:Tag) where p.nodeId = {nodeId} return COLLECT(t.name) as tagName"),
	TAG_PROGRAM_NO_CONDITION("match(p:Program) optional match (p)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, case t.name when null then '' else t.name end as tagName order by p.name"),
//	TAG_PROGRAM_NO_CONDITION("match(p:Program)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, t.name as tagName order by p.name union "
//			+"match(p:Program) return p.nodeId as nodeId, p.name as name, '' as tagName"),
	TAG_PARAGRAPH("match(p:Paragraph)-[:has_tag]->(t:Tag) where p.isExit = 'N' return p.nodeId as nodeId, p.name as name, t.name as tagName"),
	TAG_PARAGRAPH_NO_CONDITION("match(p:Paragraph) where p.isExit = 'N' optional match (p)-[:has_tag]->(t:Tag) return p.nodeId as nodeId, p.name as name, case t.name when null then '' else t.name end as tagName order by p.name"),
//	TAG_PARAGRAPH_NO_CONDITION("match(p:Paragraph)-[:has_tag]->(t:Tag) where p.isExit = 'N' return p.nodeId as nodeId, p.name as name, t.name as tagName order by p.name union "
//		+"match(p:Paragraph) where p.isExit = 'N' return p.nodeId as nodeId, p.name as name, '' as tagName"),
	ADD_PROGRAM_TAG("match(p:Program) where p.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p1:has_tag]->(t) on create set p1.label = 'has_tag' return p.name as name,t.name as tagName"),
	ADD_PROGRAM_TAG_WITHOUT("match(p:Program) where p.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p1:without_tag]->(t) on create set p1.label = 'without_tag' return p.name as name,t.name as tagName"),
	ADD_PROGRAM_TAG_WITH_NODEID("match(p:Program) where p.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p1:has_tag]->(t) on create set p1.label = 'has_tag' return p.name as name,t.name as tagName"),
	ADD_PROGRAM_TAG_WITH_NODEID_WITHOUT("match(p:Program) where p.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p1:without_tag]->(t) on create set p1.label = 'without_tag' return p.name as name,t.name as tagName"),
//	ADD_TAG("match(p:Program) where p.name in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p1:has_tag]->(t) on create set p1.label = 'has_tag' return p.name as name,t.name as tagName union "
//			+ "match(p:Paragraph) where p.name in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return p.name as name, t.name as tagName"),
	ADD_TAG_WITH_NODEID("match(p:Program) where p.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p1:has_tag]->(t) on create set p1.label = 'has_tag' return p.name as name,t.name as tagName union "
			+ "match(p:Paragraph) where p.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return p.name as name, t.name as tagName"),
	ADD_TAG_WITH_NODEID_WITHOUT("match(p:Program) where p.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p1:without_tag]->(t) on create set p1.label = 'without_tag' return p.name as name,t.name as tagName union "
		    + "match(p:Paragraph) where p.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (p)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return p.name as name, t.name as tagName"),   
	ADD_TABLE_TAG("match(t:Table) where t.nodeId in {names} merge (t1:Tag{name:{tagName}}) on create set t1.nodeId={tagName}  merge (t)-[p1:has_tag]->(t1) on create set p1.label = 'has_tag' return t.name as name, t1.name as tagName"),
	ADD_TABLE_TAG_WITHOUT("match(t:Table) where t.nodeId in {names} merge (t1:Tag{name:{tagNte}}) on create set t1.nodeId={tagName}  merge (t)-[p1:without_tag]->(t1) on create set p1.label = 'without_tag' return t.name as name, t1.name as tagName"),
	ADD_FILE_TAG("match(f:File) where f.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (f)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return f.name as name, t.name as tagName"),
	ADD_FILE_TAG_WITHOUT("match(f:File) where f.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (f)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return f.name as name, t.name as tagName"),
	ADD_COPYBOOK_TAG("match(c:Copybook) where c.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (c)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return c.name as name, t.name as tagName"),
	ADD_COPYBOOK_TAG_WITHOUT("match(c:Copybook) where c.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (c)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return c.name as name, t.name as tagName"),
	ADD_COPYBOOK_TAG_WITH_NAME("match(c:Copybook) where c.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (c)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return c.name as name, t.name as tagName"),
	ADD_COPYBOOK_TAG_WITH_NAME_WITHOUT("match(c:Copybook) where c.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (c)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return c.name as name, t.name as tagName"),
	REMOVE_PROGRAM_TAG("match(p:Program)-[p1:has_tag]->(t:Tag)  where p.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return p.name as name"),
	REMOVE_PROGRAM_TAG_WITHOUT("match(p:Program)-[p1:without_tag]->(t:Tag)  where p.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return p.name as name"),	
	REMOVE_PROGRAM_TAG_WITH_NODEID("match(p:Program)-[p1:has_tag]->(t:Tag)  where p.nodeId in {names} and t.name in {tagNames} detach delete p1 return p.name as name"),
	REMOVE_PROGRAM_TAG_WITH_NODEID_WITHOUT("match(p:Program)-[p1:without_tag]->(t:Tag)  where p.nodeId in {names} and t.name in {tagNames} detach delete p1 return p.name as name"),	
//	REMOVE_TAG("match(p:Program)-[p1:has_tag]->(t:Tag)  where p.name in {names} and t.name in {tagNames} detach delete p1 return p.name as name union "
//			+ "match(p:Paragraph)- [p2:has_tag]->(t:Tag)  where p.name in {names} and t.name in {tagNames} detach delete p2 return p.name as name"),
	REMOVE_TAG_WITH_NODEID("match(p:Program)-[p1:has_tag]->(t:Tag)  where p.nodeId in {names} and t.name = {tagName} detach delete p1 return p.name as name union "
			+ "match(p:Paragraph)- [p2:has_tag]->(t:Tag)  where p.nodeId in {names} and t.name = {tagName} detach delete p2 return p.name as name"),
	REMOVE_TAG_WITH_NODEID_WITHOUT("match(p:Program)-[p1:without_tag]->(t:Tag)  where p.nodeId in {names} and t.name = {tagName} detach delete p1 return p.name as name union "
	        + "match(p:Paragraph)- [p2:without_tag]->(t:Tag)  where p.nodeId in {names} and t.name = {tagName} detach delete p2 return p.name as name"),
	REMOVE_TABLE_TAG("match(t:Table)-[p1:has_tag]->t1:Tag)  where t.nodeId in {names} and t1.name in {tagNames} detach delete p1 return t.name as name"),
	REMOVE_TABLE_TAG_WITHOUT("match(t:Table)-[p1:without_tag]->(t1:Tag)  where t.nodeId in {names} and t1.name in {tagNames} detach delete p1 return t.name as name"),
	REMOVE_FILE_TAG("match(f:File)- [p2:has_tag]->(t:Tag)  where f.nodeId in {names} and t.name in {tagNames} detach delete p2 return f.name as name"),
	REMOVE_FILE_TAG_WITHOUT("match(f:File)- [p2:without_tag]->(t:Tag)  where f.nodeId in {names} and t.name in {tagNames} detach delete p2 return f.name as name"),
	REMOVE_COPYBOOK_TAG("match(c:Copybook)- [p2:has_tag]->(t:Tag)  where c.nodeId in {names} and t.name in {tagNames} detach delete p2 return c.name as name"),
	REMOVE_COPYBOOK_TAG_WITHOUT("match(c:Copybook)- [p2:without_tag]->(t:Tag)  where c.nodeId in {names} and t.name in {tagNames} detach delete p2 return c.name as name"),
	REMOVE_COPYBOOK_TAG_WITH_NAME("match(c:Copybook)- [p2:has_tag]->(t:Tag)  where c.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p2 return c.name as name"),
	REMOVE_COPYBOOK_TAG_WITH_NAME_WITHOUT("match(c:Copybook)- [p2:without_tag]->(t:Tag)  where c.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p2 return c.name as name"),
	ADD_JCL_TAG("match(j:JclFile) where j.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return j.name as name, t.name as tagName"),
	ADD_JCL_TAG_WITHOUT("match(j:JclFile) where j.nodeId in {names} merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return j.name as name, t.name as tagName"),
//	ADD_JOB_TAG_WITH_NAME("match(j:JclFile) where j.isProc = 'N' and j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return j.name as name, t.name as tagName"),
	ADD_JOB_TAG_WITH_NAME("match(j:JclFile) where j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return j.name as name, t.name as tagName"),
//	ADD_JOB_TAG_WITH_NAME_WITHOUT("match(j:JclFile) where j.isProc = 'N' and j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return j.name as name, t.name as tagName"),
	ADD_JOB_TAG_WITH_NAME_WITHOUT("match(j:JclFile) where j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return j.name as name, t.name as tagName"),
//	ADD_PROC_TAG_WITH_NAME("match(j:JclFile) where j.isProc = 'Y' and j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return j.name as name, t.name as tagName"),
	ADD_PROC_TAG_WITH_NAME("match(j:JclFile) where j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:has_tag]->(t) on create set p2.label = 'has_tag' return j.name as name, t.name as tagName"),
//	ADD_PROC_TAG_WITH_NAME_WITHOUT("match(j:JclFile) where j.isProc = 'Y' and j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return j.name as name, t.name as tagName"),
	ADD_PROC_TAG_WITH_NAME_WITHOUT("match(j:JclFile) where j.nodeId contains ('/'+{names}+'/') merge (t:Tag{name:{tagName}}) on create set t.nodeId={tagName}  merge (j)-[p2:without_tag]->(t) on create set p2.label = 'without_tag' return j.name as name, t.name as tagName"),
	REMOVE_JCL_TAG("match(j:JclFile)-[p1:has_tag]->(t:Tag)  where j.nodeId in {names} and t.name in {tagNames} detach delete p1 return j.name as name"),
	REMOVE_JCL_TAG_WITHOUT("match(j:JclFile)-[p1:without_tag]->(t:Tag)  where j.nodeId in {names} and t.name in {tagNames} detach delete p1 return j.name as name"),
//	REMOVE_JOB_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag)  where j.isProc = 'N' and j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
	REMOVE_JOB_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag)  where j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
//	REMOVE_JOB_TAG_WITH_NAME_WITHOUT("match(j:JclFile)-[p1:without_tag]->(t:Tag)  where j.isProc = 'N' and j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
	REMOVE_JOB_TAG_WITH_NAME_WITHOUT("match(j:JclFile)-[p1:without_tag]->(t:Tag)  where j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
//	REMOVE_PROC_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag)  where j.isProc = 'Y' and j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
	REMOVE_PROC_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag)  where j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
//	REMOVE_PROC_TAG_WITH_NAME_WITHOUT("match(j:JclFile)-[p1:without_tag]->(t:Tag)  where j.isProc = 'Y' and j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
	REMOVE_PROC_TAG_WITH_NAME_WITHOUT("match(j:JclFile)-[p1:without_tag]->(t:Tag)  where j.nodeId contains ('/'+{names}+'/') and t.name in {tagNames} detach delete p1 return j.name as name"),
	ALL_TAG("match(t:Tag) return t.name as tagName"),
	ALL_PROGRM_TAG("match(p:Program)-[p1:has_tag]->(t:Tag) where p.name in {name} return 'Program' as type, t.name as tags "),
	ALL_PROGRM_TAG_DENY("match(p:Program)-[p1:without_tag]->(t:Tag) where p.name in {name} return 'Program' as type, t.name as tags "),
	ALL_PROGRM_WITH_FILE_NAME_TAG("match(p:Program)-[p1:has_tag]->(t:Tag) where p.nodeId contains ('/'+{name}+'/') return 'Program' as type, t.name as tags "),
	ALL_PROGRM_WITH_FILE_NAME_TAG_DENY("match(p:Program)-[p1:without_tag]->(t:Tag) where p.nodeId contains ('/'+{name}+'/') return 'Program' as type, t.name as tags "),	
//	ALL_PROGRM_PARAGRAPH_TAG("match(p:Program)-[p1:has_tag]->(t:Tag) where p.name in {name} return 'Program' as type, t.name as tags union "+
//								"match(p:Paragraph)-[p2:has_tag]->(t:Tag) where p.name in {name} return 'Paragraph' as type, t.name as tags"),
	ALL_TABLE_TAG("match(t:Table)-[p1:has_tag]->(t1:Tag) where t.nodeId in {name} return 'Table' as type, t1.name as tags"),
	ALL_TABLE_TAG_DENY("match(t:Table)-[p1:without_tag]->(t1:Tag) where t.nodeId in {name} return 'Table' as type, t1.name as tags"),	
	ALL_FILE_TAG("match(f:File)-[p2:has_tag]->(t:Tag) where f.nodeId in {name} return 'File' as type, t.name as tags"),
	ALL_FILE_TAG_DENY("match(f:File)-[p2:without_tag]->(t:Tag) where f.nodeId in {name} return 'File' as type, t.name as tags"),
	ALL_COPYBOOK_TAG("match(c:Copybook)-[p2:has_tag]->(t:Tag) where c.nodeId in {name} return 'Copybook' as type, t.name as tags"),
	ALL_COPYBOOK_TAG_DENY("match(c:Copybook)-[p2:without_tag]->(t:Tag) where c.nodeId in {name} return 'Copybook' as type, t.name as tags"),	
	ALL_COPYBOOK_TAG_WITH_NAME("match(c:Copybook)-[p2:has_tag]->(t:Tag) where c.nodeId contains ('/'+{name}+'/') return 'Copybook' as type, t.name as tags"),
	ALL_COPYBOOK_TAG_WITH_NAME_DENY("match(c:Copybook)-[p2:without_tag]->(t:Tag) where c.nodeId contains ('/'+{name}+'/') return 'Copybook' as type, t.name as tags"),	
	ALL_JCL_TAG("match(j:JclFile)-[p1:has_tag]->(t:Tag) where j.nodeId in {name} return 'Jcl' as type, t.name as tags"),
	ALL_JCL_TAG_DENY("match(j:JclFile)-[p1:without_tag]->(t:Tag) where j.nodeId in {name} return 'Jcl' as type, t.name as tags"),
//	ALL_JOB_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag) where j.isProc = 'N' and j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),
	ALL_JOB_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag) where j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),
//	ALL_JOB_TAG_WITH_NAME_DENY("match(j:JclFile)-[p1:without_tag]->(t:Tag) where j.isProc = 'N' and j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),
	ALL_JOB_TAG_WITH_NAME_DENY("match(j:JclFile)-[p1:without_tag]->(t:Tag) where j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),
//	ALL_PROC_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag) where j.isProc = 'Y' and j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),
	ALL_PROC_TAG_WITH_NAME("match(j:JclFile)-[p1:has_tag]->(t:Tag) where j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),
//	ALL_PROC_TAG_WITH_NAME_DENY("match(j:JclFile)-[p1:without_tag]->(t:Tag) where j.isProc = 'Y' and j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),	
	ALL_PROC_TAG_WITH_NAME_DENY("match(j:JclFile)-[p1:without_tag]->(t:Tag) where j.nodeId contains ('/'+{name}+'/') return 'Jcl' as type, t.name as tags"),
	GET_PARAGRAPH_CONTENT("match(p1:Paragraph) where p1.name in {paraNames} return p1.name as name, blm.content(p1.location) as content"),
	PARAGRAPH_CODE("match(p:Paragraph{nodeId:{paraName}}) return blm.content(p.location) as content"),
	
	PARAGRAPH_COMPLEXITY("match(b:BlockPosition)-[:blockToParagraph]->(p:Paragraph), (b1:BlockPosition)-[r]-(b2:BlockPosition) where p.isExit = 'N' and b1.nodeId contains p.nodeId and b2.nodeId contains p.nodeId with p, (count(distinct(r))-count(distinct(b1))+2) as complexity set p.complexity = complexity return p.nodeId as nodeId union "
			+" match(n:Program)-[:has_paragraph]-(p:Paragraph) with n, max(coalesce(p.complexity,0)) as complexity set n.complexity = complexity return n.nodeId as nodeId"),
	
	QUERY_PARAGRAPH_LOOP("match(p:Paragraph), (b1:BlockPosition) where  b1.type='LOOP_BLOCK' and p.isExit = 'N' and b1.nodeId contains p.nodeId and toInt(b1.startLine)>= toInt(p.startLine) and toInt(b1.endLine)<= toInt(p.endLine) return p.nodeId as nodeId , count(b1) as loop"),
	
	QUERY_PARAGRAPH_CONDITION("match(p:Paragraph), (b1:BlockPosition) where  b1.type='CONDITION' and p.isExit = 'N' and b1.nodeId contains p.nodeId and toInt(b1.startLine)>= toInt(p.startLine) and toInt(b1.endLine)<= toInt(p.endLine) return p.nodeId as nodeId , count(b1) as condition"),
	
	QUERY_PARAGRAPH_VARIABLE("match (p:Paragraph), (b:BlockPosition)-[:blockToDataFlow]->(d:DataFlow)-[:input|output]-(v:Variable) where p.isExit = 'N' and toInt(b.startLine)>= toInt(p.startLine) and toInt(b.endLine)<= toInt(p.endLine) return p.nodeId as nodeId , coalesce(count(distinct(v)),0) as variable"),
	
	QUERY_PARAGRAPH_COMPLEXITY("match(p:Paragraph) return p.nodeId as nodeId, coalesce(p.complexity,0)"),
	COST_PROGRAM_BASIC("match(p:Program)-[:has_paragraph]-(n:Paragraph) where n.isExit = 'N' return p.nodeId as nodeId, p.name as name, p.totalLine as totalLine, coalesce(p.complexity,0) as complexity, count(n) as count"),
	COST_PROGRAM_COUNT(" match (t:Table)-[:table_has_column]->(c:Column)-[r:colDataFlowToVar|varDataFlowToCol]->(:Variable) where r.inProgramId = {nodeId} return count(DISTINCT(t)) as count, 'table' as type union "
			+"match(d:DataFlow)-[:input|output]-(v:Variable) where v.nodeId starts with({nodeId}) return count(distinct(v.nodeId)) as count, 'variable' as type union "
			+"match(b:BlockPosition) where b.nodeId starts with({nodeId}) return count(distinct(b.nodeId)) as count, case b.type when 'LOOP_BLOCK' then 'loop' when 'CONDITION_BLOCK' then 'condition' end as type"),
//			+" match(b:BlockPosition) where b.nodeId starts with({nodeId}) and b.type = 'LOOP_BLOCK'  return count(distinct(b.nodeId)) as count, 'loop' as type union "
//			+" match(b1:BlockPosition) where b1.nodeId starts with({nodeId}) and b1.type = 'CONDITION_BLOCK'  return count(distinct(b1.nodeId)) as count, 'condition' as type"),
	COST_PARAGRAPH_BASIC("match(p:Program)-[:has_paragraph]-(n:Paragraph) where p.nodeId = {programNodeId} and n.isExit = 'N' return n.nodeId as nodeId, n.name as name, n.totalLine as totalLine, coalesce(n.complexity,0) as complexity"),
	COST_PARAGRAPH_COUNT("match (t:Table)-[:table_has_column]->(c:Column)-[r:colDataFlowToVar|varDataFlowToCol]->(:Variable) where r.inParagraphId = {nodeId} return count(DISTINCT(t)) as count, 'table' as type union "
			+" match (b:BlockPosition)-[:blockToDataFlow]->(d:DataFlow)-[:input|output]-(v:Variable) where b.nodeId starts with {nodeId} return count(DISTINCT(v.nodeId)) as count, 'variable' as type union "
			+" match(b:BlockPosition) where b.nodeId starts with {nodeId} return count(distinct(b.nodeId)) as count, case b.type when 'LOOP_BLOCK' then 'loop' when 'CONDITION_BLOCK' then 'condition' end as type"),
//			+" match(b:BlockPosition) where b.nodeId starts with {nodeId} and b.type = 'LOOP_BLOCK' return count(distinct(b.nodeId)) as count, 'loop' as type union "
//			+" match(b:BlockPosition) where b.nodeId starts with {nodeId} and b.type = 'CONDITION_BLOCK' return count(distinct(b.nodeId)) as count, 'condition' as type"),
	SET_PARA_CLONE("unwind{batch} as event match(p:Paragraph) where p.name = event.name set p.clone = event.cloneLines, p.clonePercentage = event.clonePercentage"),
	SET_PROGRAM_CLONE("unwind{batch} as event match(n:Program) where n.nodeId = event.nodeId set n.clone = event.clone, n.clonePercentage = event.percentage"),
	TOTAL_CLONE("match(p:Program) return sum(coalesce(toInteger(p.clone),0)) as clone, collect(p.clonePercentage >= {threshold}) as count limit 1 union "
			+" match(p:Program)-[:has_paragraph]->(p1:Paragraph) return sum(toInteger(p1.totalLine)) as clone, count(p1.nodeId) as count limit 1"),
	GET_COPY_COMMAND("match(cp:CopyCommand)-[:copy]->(c:Copybook) where c.nodeId = {nodeId} return COLLECT(cp.nodeId) as copyCommands, collect(cp.line) as copyLines limit 1"),
	FIND_PROGRAM("match(n:Program) where n.nodeId starts with {nodeId} return n.nodeId as nodeId"),
	PROGRAM_WITH_ALL_PARAGRAPH("match(n:Program)-[:has_paragraph]-(p:Paragraph) return n.nodeId as nodeId, n.name as name, sum(toInteger(p.totalLine)) as totalParaLine,collect(p.name) as paraNames")
	;
	
	private String cypherMethod;

	CypherMethod(String cypherMethod) {
		this.cypherMethod = cypherMethod;
	}
	
    @Override  
    public String toString() {  
        return this.cypherMethod; 
    }
}
